---
author: Arsenij Ustjanzew
title: scRNA-seq
output:
  flexdashboard::flex_dashboard:
    theme: yeti
    social: null
    source: null
    navbar: []
runtime: shiny
---

```{r i2dash-global-setup}
# Deal with operation within a switchr environment
if (any(grepl(pattern = ".switchr", x = .libPaths()))) {
  switchr::switchrNoUnload(TRUE)
}

# Make it possible to reuse chunk labels
options(knitr.duplicate.label = "allow")

# Set datadir variable, components should fetch their env from here!
datadir <- "datadir_demo"

# Set up color mappings
colormaps <- list()
```

Introduction {data-navmenu=""}
====================================================

<!-- Page created on 2020-06-09 10:46:01 -->


Column
-------------------------------------
    
### 

**References:**

Rapolas Z. et al. (2019). *Single-Cell Transcriptomics of Human and Mouse Lung Cancers Reveals Conserved Myeloid Populations across Individuals and Species.* Immunity 50, 1317-1334.

**Abstract:**

Tumor-infiltrating myeloid cells (TIMs) comprise monocytes, macrophages, dendritic cells, and neutrophils, and have emerged as key regulators of cancer growth. These cells can diversify into a spectrum of states, which might promote or limit tumor outgrowth but remain poorly understood. Here, we used single-cell RNA sequencing (scRNA-seq) to map TIMs in non-small-cell lung cancer patients. We uncovered 25 TIM states, most of which were reproducibly found across patients. To facilitate translational research of these populations, we also profiled TIMs in mice. In comparing TIMs across species, we identified a near-complete congruence of population structures among dendritic cells and monocytes; conserved neutrophil subsets; and species differences among macrophages. By contrast, myeloid cell population structures in patients' blood showed limited overlap with those of TIMs. This study determines the lung TIM landscape and sets the stage for future investigations into the potential of TIMs as immunotherapy targets.

---

**scRNA-seq of CD45-positive cells from lungs of 2 healthy mice and 2 lung tumor-bearing mice were used.**

Data obtained from [here](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE127465)

A sample of the data set with 2000 cells was used for better performance. Full data contained 15939 cells:

```
class: SingleCellExperiment 
dim: 28205 2000 
metadata(0):
assays(1): counts
rownames(28205): 0610007P14Rik 0610009B22Rik ... mt-Nd5 mt-Nd6
rowData names(0):
colnames(2000): bc1351_h_2_3 bc0897_t_1_1 ... bc0979_t_1_1 bc155_t_1_5
colData names(24): Tumor.or.healthy Biological.replicate ... high_subsets_Mito_percent discard
reducedDimNames(1): Spring_redDim
altExpNames(0):
```

 


Column
-------------------------------------
    
### 


<div>
<img src="fig1.jpg" style="width:100%;height:auto;">
</div>

**Single cell transcriptional profiling of mouse and human immune cells in non-small cell lung cancer**

- **A**. Schematic of experimental workflow for defining and comparing immune transcriptional states in both species. Single cell suspensions for scRNAseq were prepared from patient lung tumor biopsies (n=7), murine lung tumors (n=2), and murine healthy lung tissue (n=2).

- **B**. Two-dimensional visualization (SPRING plots) of immune and non-immune single cell transcriptomes (n= 40,362) in patient lung tumor biopsies (n=7).

- **C, D**. SPRING plots of lung immune cells from (C) human patients (34,450 cells) and (D) mice (15,939 cells). Major cell types were defined by a Bayesian cell classifier using bulk whole-transcriptome profiles of FACS-sorted cell populations.

    

Quality Control {.storyboard data-navmenu=""}
====================================================

<!-- Page created on 2020-06-09 10:46:01 -->

### Total UMI count for each barcode in the dataset, plotted against its rank in decreasing order of total counts (Blue line = inflection; Green line = knee).

<!-- Component created on 2020-06-09 10:40:27 -->

```{r}
if (!requireNamespace("plotly", quietly = TRUE)) {
    stop('The package "plotly" is needed to embed objects of class "plotly".', call. = FALSE)
}

vis_obj_s4ExJL <- readRDS(file.path(datadir, 'obj_s4ExJL.rds'))

# workaround for plotly dependencies issue (https://github.com/ropensci/plotly/issues/1044)
# 
fix_dependency <- function(dependency){
  if(dependency$name == "crosstalk" & dependency$version == "1.1.0"){
    if(dependency$name == "jquery") dependency$src$file <- file.path(system.file(package ="crosstalk"), "lib/jquery")
    if(dependency$name == "crosstalk") dependency$src$file <- file.path(system.file(package ="crosstalk"), "www")
  }
  return(dependency)
}
if ("plotly" == "plotly"){
  vis_obj_s4ExJL$dependencies <- lapply(vis_obj_s4ExJL$dependencies, fix_dependency)  
}

vis_obj_s4ExJL
```


### Total number of counts and the number of detected genes for the cell grouped by condition.

<!-- Component created on 2020-06-09 10:40:58 -->

```{r}
env_ZPwUen <- readRDS(file.path(datadir, "env_ZPwUen.rds"))
is_shiny <- identical(knitr::opts_knit$get("rmarkdown.runtime"), "shiny")
library(magrittr)
```

```{r, eval=!is_shiny}
# selecting the first numeric and factor column for object wrapper 
env_ZPwUen$y %>%
  as.data.frame() %>%
  dplyr::select_if(function(col) is.integer(col) | is.numeric(col)) %>%
  dplyr::select(1) -> y_env_ZPwUen

if(!is.null(env_ZPwUen$group_by)){
  env_ZPwUen$group_by %>%
    as.data.frame() %>%
    dplyr::select_if(is.factor) %>%
    dplyr::select(1) -> group_by_env_ZPwUen
  group_by_title_env_ZPwUen <- colnames(group_by_env_ZPwUen)
} else {
  group_by_title_env_ZPwUen <- NULL
  group_by_env_ZPwUen <- NULL
}

# compare with colormaps
if(!is.null(group_by_title_env_ZPwUen)){
  if(group_by_title_env_ZPwUen %in% names(colormaps)) colors_env_ZPwUen <- colormaps[[group_by_title_env_ZPwUen]] else colors_env_ZPwUen <- "Set1"
} else {
  colors_env_ZPwUen <- "Set1"
}

# set title variables
if(!is.null(env_ZPwUen$y_title)) y_title_env_ZPwUen <- env_ZPwUen$y_title else y_title_env_ZPwUen <- colnames(y_env_ZPwUen)
if(!is.null(env_ZPwUen$group_by_title)) group_by_title_env_ZPwUen <- env_ZPwUen$group_by_title

# creating the plot object
plot_env_ZPwUen <- i2dash.scrnaseq::plotly_violinplot(y = y_env_ZPwUen[,1], group_by = group_by_env_ZPwUen[,1], y_title = y_title_env_ZPwUen, group_by_title = group_by_title_env_ZPwUen, colors = colors_env_ZPwUen)

# Provide data for download
if(!is.null(env_ZPwUen$group_by)) download_df_env_ZPwUen <- data.frame(y_env_ZPwUen, group_by_env_ZPwUen) else download_df_env_ZPwUen <- data.frame(y_env_ZPwUen)
rownames(download_df_env_ZPwUen) <- rownames(env_ZPwUen$y)
htmltools::div(style="display:block;float:left;width:100%;height:90%;",
  htmltools::tags$button(i2dash::embed_var(download_df_env_ZPwUen)), plot_env_ZPwUen
)
```

```{r, eval=is_shiny}
ui_list <- list()

#
# shiny input widget for y
#
if (env_ZPwUen$y_selection){
  ui_list <- rlist::list.append(ui_list,
                                selectInput("select_y_env_ZPwUen", label = "Select observations:",
                                            choices = colnames(env_ZPwUen$y[lapply(env_ZPwUen$y,class) =="numeric" | lapply(env_ZPwUen$y,class) =="integer"])))
}

#
# shiny input widget for group_by
#
if (env_ZPwUen$group_by_selection){
  ui_list <- rlist::list.append(ui_list,
                                selectInput("select_group_by_env_ZPwUen", label = "Group observations by:",
                                            choices = colnames(env_ZPwUen$group_by[lapply(env_ZPwUen$group_by,class) =="factor"])))
}
#
# shiny download button
#
ui_list <- rlist::list.append(ui_list, tags$div(tags$br(), downloadButton('downloadData_env_ZPwUen', 'Download data')))

#
# Handle inputs
#
if( !env_ZPwUen$y_selection){
  y_env_ZPwUen <- shiny::reactive({
    data <- env_ZPwUen$y[[1]]
    title <- colnames(env_ZPwUen$y)[1]
    return(list(data = data, title = title))
  })
} else {
  y_env_ZPwUen <- shiny::reactive({
    data <- env_ZPwUen$y[[input$select_y_env_ZPwUen]]
    title <- input$select_y_env_ZPwUen
    return(list(data = data, title = title))
  })
}

if( !env_ZPwUen$group_by_selection ) {
  group_by_env_ZPwUen <- shiny::reactive({
    data <- env_ZPwUen$group_by[[1]]
    title <- colnames(env_ZPwUen$group_by)[1]
    return(list(data = data, title = title))
  })
} else {
  group_by_env_ZPwUen <- shiny::reactive({
    data <- env_ZPwUen$group_by[[input$select_group_by_env_ZPwUen]]
    title <- input$select_group_by_env_ZPwUen
    return(list(data = data, title = title))
  })
}

#
# Download data.frame
#
output$downloadData_env_ZPwUen <- downloadHandler(
  filename =  paste('data-', Sys.Date(), '.csv', sep=''),
  content = function(file) {
    if(is.null(env_ZPwUen$group_by)){
      df <- y_env_ZPwUen()$data
    } else {
      df <- data.frame(y_env_ZPwUen()$data, group_by_env_ZPwUen()$data)
    }
    rownames(df) <- rownames(env_ZPwUen$y)
    write.csv(df, file)
    
  }
)

#
# reactive for plot creation
#
output$plot_env_ZPwUen <- plotly::renderPlotly({
  # compare with colormaps
  if(!is.null(group_by_env_ZPwUen()$title)){
    if(group_by_env_ZPwUen()$title %in% names(colormaps)) colors <- colormaps[[group_by_env_ZPwUen()$title]] else colors <- "Set1"
  } else {
    colors <- "Set1"
  }
  
  # set custom axis titles if provided
  if(!is.null(env_ZPwUen$y_title)) y_title <- env_ZPwUen$y_title else y_title <- y_env_ZPwUen()$title
  if(!is.null(env_ZPwUen$group_by_title)) group_by_title <- env_ZPwUen$group_by_title else group_by_title <- group_by_env_ZPwUen()$title
  
  i2dash.scrnaseq::plotly_violinplot(y = y_env_ZPwUen()$data, group_by = group_by_env_ZPwUen()$data, y_title = y_title, group_by_title = group_by_title, colors = colors)
})

#
# Layout of component
#
shiny::fillRow(flex = c(NA, 1),
      shinyWidgets::dropdownButton(div(style='max-height: 350px; overflow-x: auto;',do.call(shiny::inputPanel, ui_list)),
                       circle = TRUE, status = "danger", icon = icon("gear"), width = "300px",
                       tooltip = shinyWidgets::tooltipOptions(title = "Click, to change plot settings:")),
      plotly::plotlyOutput("plot_env_ZPwUen", height = "100%")
)
```

### Scatterplot of reads mapped to mitochondrial transcripts (%) against detected genes, coloured by discarded cells (red). Each point represents a cell.

<!-- Component created on 2020-06-09 10:45:55 -->

```{r}
if (!requireNamespace("plotly", quietly = TRUE)) {
    stop('The package "plotly" is needed to embed objects of class "plotly".', call. = FALSE)
}

vis_obj_O5Etz3 <- readRDS(file.path(datadir, 'obj_O5Etz3.rds'))

# workaround for plotly dependencies issue (https://github.com/ropensci/plotly/issues/1044)
# 
fix_dependency <- function(dependency){
  if(dependency$name == "crosstalk" & dependency$version == "1.1.0"){
    if(dependency$name == "jquery") dependency$src$file <- file.path(system.file(package ="crosstalk"), "lib/jquery")
    if(dependency$name == "crosstalk") dependency$src$file <- file.path(system.file(package ="crosstalk"), "www")
  }
  return(dependency)
}
if ("plotly" == "plotly"){
  vis_obj_O5Etz3$dependencies <- lapply(vis_obj_O5Etz3$dependencies, fix_dependency)  
}

vis_obj_O5Etz3
```


