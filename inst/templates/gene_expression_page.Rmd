###

<!-- Component created on {{ date }} -->

```{r}
{{ env_id }} = readRDS(file.path(datadir, "{{ env_id }}.rds"))

is_shiny <- identical(knitr::opts_knit$get("rmarkdown.runtime"), "shiny")

library(dplyr)
library(magrittr)

data_{{ env_id }} <- {{ env_id }}$data
group_filter_{{ env_id }} <- {{ env_id }}$group_filter
exprs_values_{{ env_id }} <- round({{ env_id }}$exprs_values,3)
reduced_dim_{{ env_id }} <- data.frame("x" = {{ env_id }}$use_dimred[,1], "y" = {{ env_id }}$use_dimred[,2])
group_by_{{ env_id }} <- {{ env_id }}$group_by

string_counts_{{ env_id }} <- apply(exprs_values_{{ env_id }}, 1, paste0, collapse = ";")
string_group_by_{{ env_id }} <- paste0(group_by_{{ env_id }}[,1], collapse = ";")
```

```{r, eval=!is_shiny}

htmltools::HTML(paste0("<div id='div_group_by_{{ env_id }}' data-grouping='",string_group_by_{{ env_id }},"'></div>"))
htmltools::HTML(paste0("<div id='", names(string_counts_{{ env_id }}),"' data-expression='", string_counts_{{ env_id }},"'></div>"))

data_{{ env_id }} %>%
  dplyr::filter(group_by == !!group_filter_{{ env_id }}) %>%
  dplyr::group_by(level, feature) %>%
  dplyr::mutate(is_non_zero_exprs = expression > 0) %>%
  dplyr::summarise(n_samples = n(), n_nonzero = sum(is_non_zero_exprs)) %>%
  dplyr::mutate(freq = round(n_nonzero / n_samples * 100, 2)) %>%
  dplyr::mutate(info = paste0(n_nonzero, " / ", n_samples, " (", freq, "%)")) %>%
  dplyr::select(level, feature, info) %>%
  tidyr::spread(level, info) %>% 
  dplyr::mutate(feature = row.names(exprs_values_{{ env_id }})) -> metadata_{{ env_id }}

  metadata_{{ env_id }} <- cbind("exprs_str" = string_counts_{{ env_id }}, "group_str" = string_group_by_{{ env_id }}, metadata_{{ env_id }})
  row.names(metadata_{{ env_id }}) <- c()
  DT::datatable(metadata_{{ env_id }}, 
                elementId = "dt_{{ env_id }}", 
                filter = 'top', 
                caption = 'Table: No. of cells with positive expression (>0)', 
                selection = list(mode = 'single', target = 'row'), 
                options = list(
    columnDefs = list(list(visible = FALSE, targets = c(1,2)))),
    callback=DT::JS("
  table.on('click.dt', 'tr', function() {
  
  // div ids of scatter and violinplot
  var id_scatter = 'scatter_{{ env_id }}';
  var id_violin = 'violin_{{ env_id }}';
  
  // get expression, featurenames and group_by values from table
  var exprs_str = table.row(this).data()[1];
  var group_str = table.row(this).data()[2];
  var featurename = table.row(this).data()[3];
  var expr = exprs_str.split(';').map(function(item){return parseFloat(item);});
  var group = group_str.split(';');
  
  // get min and max values from expression
  var min = Math.min(...expr);
  var max = Math.max(...expr);
  
  // get div container of plots
  var scatter_div = document.getElementById(id_scatter);
  var violin_div = document.getElementById(id_violin);
  
  // update scatter and violin layout - change title
  var scatter_layout_update = {title: featurename}
  var violin_layout_update = {'title': featurename,
  'xaxis.type': 'category'};
  
  // update scatterplot data
  var scatter_update_0 = {
  'marker.color': [expr],
  'marker.cmax': max,
  'marker.cmin': min,
  'marker.line.cmin': min,
  'marker.line.cmax': max,
  'marker.line.color': [expr]};

  var scatter_update_1 = {
  'marker.color': [min, max],
  'marker.cmax': max,
  'marker.cmin': min};
  
  // restyle and relayout of the scatterplot
  Plotly.restyle(id_scatter, scatter_update_0, [0]);
  Plotly.restyle(id_scatter, scatter_update_1, [1]);
  Plotly.relayout(id_scatter, scatter_layout_update);
  
  // create dict; key = number of level of group_by; value = indexes extractet from the hole expression array according to the level 
  level_indices = {}
  for (i = 0; i < violin_div.data.length; i++){
    level_name = violin_div.data[i].name;
    level_indices[i] = getAllIndexes(group, level_name);
  }
  traces_exprs = []
  // restyle each trace of the violinplot according to the indexes
  for (var key in level_indices){
    var exprs_of_level = level_indices[key].map(key => expr[key]);
    traces_exprs.push(exprs_of_level);
  }
  var violin_update = {
    y: traces_exprs
  }
  // all_traces = [...range(0, violin_div.data.length - 1)];
  Plotly.restyle(id_violin, violin_update);
  
  // change title of violinplot
  Plotly.relayout(id_violin, violin_layout_update);
  
  // function to get indexes
  function getAllIndexes(arr, val) {
    var indexes = [], i;
    for(i = 0; i < arr.length; i++)
        if (arr[i] === val)
            indexes.push(i);
    return indexes;
  }
  
  // highlight selected row of the table
  if ( $(this).hasClass('selected') ) {
      $(this).removeClass('selected');
  }
  else {
      table.$('tr.selected').removeClass('selected');
      $(this).addClass('selected');
  }
  
});
")
)
```

```{r, eval=is_shiny}
ui_list <- list()

# selection field for grouping
ui_list <- rlist::list.append(ui_list,
                                selectInput("select_grouping_{{ env_id }}", label = "Select column for grouping:",
                                            choices = unique(data_{{ env_id }}$group_by), selected = group_filter_{{ env_id }}))

# selection field for gene
ui_list <- rlist::list.append(ui_list,
                              selectInput("select_feature_{{ env_id }}", label = "Select a feature:",
                                          choices = unique(data_{{ env_id }}$feature)))

df_table_{{ env_id }} <- shiny::reactive({
  selected_group <- input$select_grouping_{{ env_id }}

  data_{{ env_id }} %>%
    dplyr::filter(group_by == !!selected_group) 
})

#
# Layout of component
#
shinyWidgets::dropdownButton(div(style='max-height: 350px; overflow-x: auto;',do.call(shiny::inputPanel, ui_list)),
                 circle = TRUE, status = "danger", icon = icon("gear"), width = "300px",
                 tooltip = shinyWidgets::tooltipOptions(title = "Click, to change plot settings:"))
renderTable({
  df_table_{{ env_id }}() %>%
    dplyr::group_by(level, feature) %>%
    dplyr::mutate(is_non_zero_exprs = expression > 0) %>%
    dplyr::summarise(n_samples = n(), n_nonzero = sum(is_non_zero_exprs)) %>%
    dplyr::mutate(freq = round(n_nonzero / n_samples * 100, 2)) %>%
    dplyr::mutate(info = paste0(n_nonzero, " / ", n_samples, " (", freq, "%)")) %>%
    dplyr::select(level, feature, info) %>%
    tidyr::spread(level, info) %>% 
    dplyr::mutate(feature = row.names(exprs_values_{{ env_id }}))
  }, height = "100%")

```

Column
-------------------------------------

###

<!-- Component created on {{ date }} -->

```{r, eval=!is_shiny}
if(is.character(group_by_{{ env_id }})){
  minimal_df <- data.frame("x" = group_by_{{ env_id }}, "y" = exprs_values_{{ env_id }}[1,])
} else {
  minimal_df <- data.frame("x" = group_by_{{ env_id }}[,1], "y" = exprs_values_{{ env_id }}[1,])
}

minimal_df %>%
  plotly::plot_ly(colors = "Set1", x = ~x, y = ~y, color = ~x, type = "violin", box = list(visible = T), meanline = list(visible = T), points = "all", jitter = 0) %>%
    plotly::layout(
      title = row.names(exprs_values_{{ env_id }})[1],
      xaxis = list(title = "Grouping"),
      yaxis = list(title = "Expression per cluster")
    ) -> violin_{{ env_id }}
violin_{{ env_id }}$elementId <- "violin_{{ env_id }}"
violin_{{ env_id }}

```
  
```{r, eval=is_shiny}
df2_{{ env_id }} <- shiny::reactive({
  keys <- plotly::event_data("plotly_selected", source = "scatter_{{ env_id }}")$key
  if(!is.null(keys)) {
    return(df_{{ env_id }}()[keys, ])
  }
  return(df_{{ env_id }}())
})

output$plot_violin_{{ env_id }} <- plotly::renderPlotly({
  violins <- plotly::plot_ly(df2_{{ env_id }}(), colors = "Set1", x = ~level, y = ~expression, color = ~level, type = "violin", box = list(visible = T), meanline = list(visible = T), points = "all", jitter = 0) %>%
    plotly::layout(
      xaxis = list(title = df_{{ env_id }}()$group_by),
      yaxis = list(title = "Expression"),
      title = input$select_feature_{{ env_id }})
})
plotly::plotlyOutput("plot_violin_{{ env_id }}", height = "100%")
```

### Select points to recalculate the violin plot according to selection:

```{r, eval=!is_shiny}
reduced_dim_{{ env_id }} %>%
  plotly::plot_ly(x = ~x , y= ~y, hoverinfo = "x+y+text", text = row.names(reduced_dim_{{ env_id }}), colors = "YlOrRd", color = exprs_values_{{ env_id }}[1,], type = "scattergl") %>%
  plotly::layout(
    title = row.names(exprs_values_{{ env_id }})[1],
    xaxis = list(title = "Dimension 1"),
    yaxis = list(title = "Dimension 2")
  ) %>% htmlwidgets::onRender("function(el) {
                                var id_violin = 'violin_{{ env_id }}';
                                var violin_div = document.getElementById(id_violin);

                                var div_group_by = document.getElementById('div_group_by_{{ env_id }}');
                                var group_str = div_group_by.getAttribute('data-grouping');
                                var group = group_str.split(';');

                                level_indices = {}
                                for (i = 0; i < violin_div.data.length; i++){
                                  level_name = violin_div.data[i].name;
                                  level_indices[i] = getAllIndexes(group, level_name);
                                }

                                el.on('plotly_selected', function(eventData){
                                  if(eventData == undefined){
                                    console.log('Nothing is selected');
                                  } else {
                                    feature_name = el.layout.title.text;
                                    var div_exprs = document.getElementById(feature_name);
                                    var exprs_str = div_exprs.getAttribute('data-expression');
                                    var expr = exprs_str.split(';').map(function(item){return parseFloat(item);});

                                    // get the array of the selected points
                                    var selection = eventData.points[0].data.selectedpoints;

                                    // create dict with subsetted trace indexes
                                    updated_dict = {}
                                    for (var key in level_indices){
                                      updated_dict[key] = selection.filter(value => -1 !== level_indices[key].indexOf(value))
                                    }

                                    // restyle each trace of the violinplot according to the indexes
                                    traces_exprs = []
                                    for (var key in updated_dict){
                                      if (updated_dict[key].length === 0){
                                        var exprs_of_level = [0];
                                        traces_exprs.push(exprs_of_level);
                                      } else {
                                        var exprs_of_level = updated_dict[key].map(key => expr[key]);
                                        traces_exprs.push(exprs_of_level);
                                      }
                                    }
                                    var violin_update = {
                                      y: traces_exprs
                                    }

                                    Plotly.restyle(id_violin, violin_update);
                                    console.log(updated_dict)

                                    var violin_layout_update = {'xaxis.type': 'category'};
                                    Plotly.relayout(id_violin, violin_layout_update);

                                    // when deselected the violin plot is restyled with the old values
                                    el.on('plotly_deselect', function(eventData){
                                      feature_name = el.layout.title.text;
                                      var div_exprs = document.getElementById(feature_name);
                                      var exprs_str = div_exprs.getAttribute('data-expression');
                                      var expr = exprs_str.split(';').map(function(item){return parseFloat(item);});

                                      traces_exprs = [];
                                      // restyle each trace of the violinplot according to the indexes
                                      for (var key in level_indices){
                                        var exprs_of_level = level_indices[key].map(key => expr[key]);
                                        traces_exprs.push(exprs_of_level);
                                      };
                                      var violin_update = {
                                        y: traces_exprs
                                      };
                                      // all_traces = [...range(0, violin_div.data.length - 1)];
                                      Plotly.restyle(id_violin, violin_update);

                                      var violin_layout_update = {'xaxis.type': 'category'};
                                      Plotly.relayout(id_violin, violin_layout_update);
                                    })
                                  }
                                });

                                // function to get indexes
                                function getAllIndexes(arr, val) {
                                  var indexes = [], i;
                                  for(i = 0; i < arr.length; i++)
                                    if (arr[i] === val)
                                      indexes.push(i);
                                  return indexes;
                                }

                              }") -> scatter_{{ env_id }}
scatter_{{ env_id }}$elementId <- "scatter_{{ env_id }}"
scatter_{{ env_id }}
```

```{r, eval=is_shiny}
#
# Create reactive data table
#
df_{{ env_id }} <- shiny::reactive({
  selected_group <- input$select_grouping_{{ env_id }}
  selected_feature <- input$select_feature_{{ env_id }}

  data_{{ env_id }} %>%
    dplyr::filter(feature == !!selected_feature, group_by == !!selected_group) 
})

#
# Download
#
output$downloadData_{{ env_id }}<- downloadHandler(
  filename =  paste('data-', Sys.Date(), '.csv', sep=''),
  content = function(file) {
    write.csv(df_{{ env_id }}(), file)
  }
)

#
# Output
#
output$plot_scatter_{{ env_id }} <- plotly::renderPlotly({
  df_{{ env_id }}() %>%
    plotly::plot_ly(colors = "YlOrRd", color = ~expression, source = "scatter_{{ env_id }}", key = rownames(df_{{ env_id }}())) %>%
    plotly::group_by(level) %>%
    plotly::add_markers(x = ~x, y = ~y, hoverinfo = "x+y+text", text = ~paste(label, "<br />Group: ", level), type = "scattergl") %>%
    plotly::layout(
      xaxis = list(title = "Dimension 1"),
      yaxis = list(title = "Dimension 2"),
      title = input$select_feature_{{ env_id }}) %>% 
    plotly::event_register("plotly_selected") -> base
  base
})

plotly::plotlyOutput("plot_scatter_{{ env_id }}", height = "100%")
```
