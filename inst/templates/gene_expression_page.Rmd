###

<!-- Component created on 2019-09-02 13:41:13 -->

```{r}
{{ env_id }} <- readRDS(file.path(datadir, "{{ env_id }}.rds"))
is_shiny <- identical(knitr::opts_knit$get("rmarkdown.runtime"), "shiny")

library(magrittr)

data_{{ env_id }} <- {{ env_id }}$data
group_filter_{{ env_id }} <- {{ env_id }}$group_filter

exprs_values_{{ env_id }} <- round({{ env_id }}$exprs_values,3)
featurenames <- rownames(exprs_values_{{ env_id }})

reduced_dim_{{ env_id }} <- {{ env_id }}$use_dimred
group_by_{{ env_id }} <- {{ env_id }}$group_by

string_counts_{{ env_id }} <- apply(exprs_values_{{ env_id }}, 1, paste0, collapse = ";")
string_group_by_{{ env_id }} <- paste0(group_by_{{ env_id }}[,1], collapse = ";")
```

```{r, eval=!is_shiny, results='asis'}
#
# Store expression data in <div> elements
#
data_divs <- lapply(featurenames, function(feature) {
  e <- string_counts_{{ env_id }}[[feature]]
  htmltools::div(id = paste0("expression-", feature), `data-feature` = feature, `data-expression` = e)
})
htmltools::div(data_divs)

htmltools::HTML(paste0("<div id='group_by_{{ env_id }}' data-grouping='",string_group_by_{{ env_id }},"'></div>"))
```

```{js, eval=!is_shiny}
/**
 * Function to link a div-container with a plotly scatterplot (needs to have only two traces), change the color values and the title of the plot.
 * @param {string} plot_id The id of the scatterplot that should be changed.
 * @param {string} div_id The id of the div container.
 * @param {string} color_by_tag The tag of the div container containing the values for the colorchange (currently as a semicolon separated string).
 * @param {string} title The new title of the scatterplot.
 */
function linking_plotly_scatter(plot_id, div_id, color_by_tag, title = "") {

  color_by = document.getElementById(div_id).getAttribute(color_by_tag);

  // (decode the data) or split the datastring
  var color_by = color_by.split(';').map(function(item){return parseFloat(item);});

  // get min and max values from expression
  var min = Math.min(...color_by);
  var max = Math.max(...color_by);
  
  // update scatterplot data
  var scatter_update_0 = {
  'marker.color': [color_by],
  'marker.cmax': max,
  'marker.cmin': min,
  'marker.line.cmax': max,
  'marker.line.cmin': min,
  'marker.line.color': [color_by]};

  var scatter_update_1 = {
  'marker.color': [min, max],
  'marker.cmax': max,
  'marker.cmin': min};

  // update scatterplot layout
  var scatter_layout_update = {title: title};
  
  // restyle and relayout of the scatterplot
  Plotly.restyle(plot_id, scatter_update_0, [0]);
  Plotly.restyle(plot_id, scatter_update_1, [1]);
  Plotly.relayout(plot_id, scatter_layout_update);
  console.log(document.getElementById(plot_id).data)
}
```

```{js, eval=!is_shiny}
/**
 * Function to link a div-container with a plotly scatterplot (needs to have only two traces), change the color values and the title of the plot.
 * @param {string} plot_id The id of the scatterplot that should be changed.
 * @param {string} samples_div_id 
 * @param {string} samples_attribute 
 * @param {string} group_div_id
 * @param {string} group_attribute
 * @param {string} title The new title of the scatterplot.
 */
function linking_plotly_violin(plot_id, samples_div_id, samples_attribute, group_div_id, group_attribute, title = "") {
  plot_div = document.getElementById(plot_id)
  values_str = document.getElementById(samples_div_id).getAttribute(samples_attribute);
  grouping_str = document.getElementById(group_div_id).getAttribute(group_attribute);
  
  // (decode the data) or split the datastring
  var values = values_str.split(';').map(function(item){return parseFloat(item);});
  var group = grouping_str.split(';');
  
  // update scatterplot layout
  var violin_layout_update = {'title': title,
      'xaxis.type': 'category'};
  
  // create dict; key = number of level of group_by; value = indexes extractet from the whole expression array according to the level
  level_indices = {}
  for (i = 0; i < plot_div.data.length; i++){
    level_name = plot_div.data[i].name;
    level_indices[i] = getAllIndexes(group, level_name);
  }
  
  // update each trace of the violinplot according to the indexes
  traces_values = []
  for (var key in level_indices){
    var values_of_level = level_indices[key].map(key => values[key]);
    traces_values.push(values_of_level);
  }
  
  var violin_update = {
    y: traces_values
  }
  
  // restyle and relayout of the violinplot
  Plotly.restyle(plot_id, violin_update);
  Plotly.relayout(plot_id, violin_layout_update);
  console.log(document.getElementById(plot_id).data)
}
```

```{js, eval=!is_shiny}
// https://stackoverflow.com/a/20798567/7508349
function getAllIndexes(arr, val) {
        var indexes = [], i;
        for(i = 0; i < arr.length; i++)
            if (arr[i] === val)
                indexes.push(i);
        return indexes;
      }
```

```{r, eval=!is_shiny}
data_{{ env_id }} %>%
  dplyr::filter(group_by == !!group_filter_{{ env_id }}) %>%
  dplyr::group_by(level, feature) %>%
  dplyr::mutate(is_non_zero_exprs = expression > 0) %>%
  dplyr::summarise(n_samples = dplyr::n(), n_nonzero = sum(is_non_zero_exprs)) %>%
  dplyr::mutate(freq = round(n_nonzero / n_samples * 100, 2)) %>%
  dplyr::mutate(info = paste0(n_nonzero, " / ", n_samples, " (", freq, "%)")) %>%
  dplyr::select(level, feature, info) %>%
  tidyr::spread(level, info) %>%
  as.data.frame -> metadata_{{ env_id }}

  row.names(metadata_{{ env_id }}) <- row.names(exprs_values_{{ env_id }})
  DT::datatable(metadata_{{ env_id }}, 
                elementId = "dt_{{ env_id }}", 
                filter = 'top', 
                caption = 'Table: No. of cells with positive expression (>0)', 
                selection = list(mode = 'single', target = 'row'), 
                options = list(
    columnDefs = list(list(visible = FALSE, targets = c(1)))
    ),
    callback=DT::JS("
      table.on('click.dt', 'tr', function() {
      
      // highlight selected row of the table
      if ( $(this).hasClass('selected') ) {
          $(this).removeClass('selected');
      } else {
          table.$('tr.selected').removeClass('selected');
          $(this).addClass('selected');
      }
      
      var feature_name = table.row(this).data()[0],
      feature_div_id = 'expression-'.concat(feature_name);
      
      // changing the scatterplot
      var id_scatter = 'scatter_{{ env_id }}';

      linking_plotly_scatter(plot_id = id_scatter, div_id = feature_div_id, color_by_tag = 'data-expression', title = feature_name);
      
      //changing the violinplot
      var id_violin = 'violin_{{ env_id }}',
      id_group = 'group_by_{{ env_id }}';
      
      linking_plotly_violin(plot_id = id_violin, samples_div_id = feature_div_id, samples_attribute = 'data-expression', group_div_id = id_group, group_attribute = 'data-grouping', title = feature_name);
      })
")
)
```


Column
-------------------------------------

###

<!-- Component created on 2019-09-02 13:41:13 -->

```{r, eval=!is_shiny}
i2dash.scrnaseq::plotly_violinplot(y = exprs_values_{{ env_id }}[1,], group_by = group_by_{{ env_id }}[,1], y_title = "Expression per cluster", group_by_title = "Grouping") %>%
  plotly::layout(
    title = row.names(exprs_values_{{ env_id }})[1]
  ) %>%
  plotly::config(fillFrame = TRUE) -> violin_{{ env_id }}
violin_{{ env_id }}$elementId <- "violin_{{ env_id }}"
violin_{{ env_id }}
```

### Select points to recalculate the violin plot according to selection:

```{r, eval=!is_shiny}
plotly::plot_ly(x = reduced_dim_{{ env_id }}[,1] , y= reduced_dim_{{ env_id }}[,2], hoverinfo = "x+y+text", text = row.names(reduced_dim_{{ env_id }}), colors = "YlOrRd", color = exprs_values_{{ env_id }}[1,], type = "scattergl") %>%
  plotly::layout(
    title = row.names(exprs_values_{{ env_id }})[1],
    xaxis = list(title = "Dimension 1"),
    yaxis = list(title = "Dimension 2")
  ) %>%
  htmlwidgets::onRender("function(el) {
    var id_violin = 'violin_{{ env_id }}';
    var violin_div = document.getElementById(id_violin);

    var div_group_by = document.getElementById('div_group_by_{{ env_id }}');
    var group_str = div_group_by.getAttribute('data-grouping');
    var group = group_str.split(';');

    level_indices = {}
    for (i = 0; i < violin_div.data.length; i++){
      level_name = violin_div.data[i].name;
      level_indices[i] = getAllIndexes(group, level_name);
    }

    el.on('plotly_selected', function(eventData){
      if(eventData == undefined){
        console.log('Nothing is selected');
      } else {
        feature_name = el.layout.title.text;
        var div_exprs = document.getElementById(feature_name);
        var exprs_str = div_exprs.getAttribute('data-expression');
        var expr = exprs_str.split(';').map(function(item){return parseFloat(item);});

        // get the array of the selected points
        var selection = eventData.points[0].data.selectedpoints;

        // create dict with subsetted trace indexes
        updated_dict = {}
        for (var key in level_indices){
          updated_dict[key] = selection.filter(value => -1 !== level_indices[key].indexOf(value))
        }

        // restyle each trace of the violinplot according to the indexes
        traces_exprs = []
        for (var key in updated_dict){
          if (updated_dict[key].length === 0){
            var exprs_of_level = [0];
            traces_exprs.push(exprs_of_level);
          } else {
            var exprs_of_level = updated_dict[key].map(key => expr[key]);
            traces_exprs.push(exprs_of_level);
          }
        }
        var violin_update = {
          y: traces_exprs
        }

        Plotly.restyle(id_violin, violin_update);
        console.log(updated_dict)

        var violin_layout_update = {'xaxis.type': 'category'};
        Plotly.relayout(id_violin, violin_layout_update);

        // when deselected the violin plot is restyled with the old values
        el.on('plotly_deselect', function(eventData){
          feature_name = el.layout.title.text;
          var div_exprs = document.getElementById(feature_name);
          var exprs_str = div_exprs.getAttribute('data-expression');
          var expr = exprs_str.split(';').map(function(item){return parseFloat(item);});

          traces_exprs = [];
          // restyle each trace of the violinplot according to the indexes
          for (var key in level_indices){
            var exprs_of_level = level_indices[key].map(key => expr[key]);
            traces_exprs.push(exprs_of_level);
          };
          var violin_update = {
            y: traces_exprs
          };
          // all_traces = [...range(0, violin_div.data.length - 1)];
          Plotly.restyle(id_violin, violin_update);

          var violin_layout_update = {'xaxis.type': 'category'};
          Plotly.relayout(id_violin, violin_layout_update);
        })
      }
    });
  }") %>%
  plotly::config(fillFrame = TRUE) -> scatter_{{ env_id }}

# %>%
#   plotly::config(fillFrame = TRUE) -> scatter_{{ env_id }}

scatter_{{ env_id }}$elementId <- "scatter_{{ env_id }}"
scatter_{{ env_id }}
```


