###

<!-- Component created on {{ date }} -->

```{r}
env_blHKgM <- readRDS(file.path(datadir, "env_blHKgM.rds"))
is_shiny <- identical(knitr::opts_knit$get("rmarkdown.runtime"), "shiny")

library(magrittr)

data_env_blHKgM <- env_blHKgM$data
group_filter_env_blHKgM <- env_blHKgM$group_filter

exprs_values_env_blHKgM <- round(env_blHKgM$exprs_values,3)
featurenames <- rownames(exprs_values_env_blHKgM)

reduced_dim_env_blHKgM <- env_blHKgM$use_dimred
group_by_env_blHKgM <- env_blHKgM$group_by

string_counts_env_blHKgM <- apply(exprs_values_env_blHKgM, 1, paste0, collapse = ";")
string_group_by_env_blHKgM <- paste0(group_by_env_blHKgM[,1], collapse = ";")
```

```{r, eval=!is_shiny}

htmltools::HTML(paste0("<div id='div_group_by_{{ env_id }}' data-grouping='",string_group_by_{{ env_id }},"'></div>"))
htmltools::HTML(paste0("<div id='", names(string_counts_{{ env_id }}),"' data-expression='", string_counts_{{ env_id }},"'></div>"))

data_{{ env_id }} %>%
  dplyr::filter(group_by == !!group_filter_{{ env_id }}) %>%
  dplyr::group_by(level, feature) %>%
  dplyr::mutate(is_non_zero_exprs = expression > 0) %>%
  dplyr::summarise(n_samples = n(), n_nonzero = sum(is_non_zero_exprs)) %>%
  dplyr::mutate(freq = round(n_nonzero / n_samples * 100, 2)) %>%
  dplyr::mutate(info = paste0(n_nonzero, " / ", n_samples, " (", freq, "%)")) %>%
  dplyr::select(level, feature, info) %>%
  tidyr::spread(level, info) %>% 
  dplyr::mutate(feature = row.names(exprs_values_{{ env_id }})) -> metadata_{{ env_id }}

  metadata_{{ env_id }} <- cbind("exprs_str" = string_counts_{{ env_id }}, "group_str" = string_group_by_{{ env_id }}, metadata_{{ env_id }})
  row.names(metadata_{{ env_id }}) <- c()
  DT::datatable(metadata_{{ env_id }}, 
                elementId = "dt_{{ env_id }}", 
                filter = 'top', 
                caption = 'Table: No. of cells with positive expression (>0)', 
                selection = list(mode = 'single', target = 'row'), 
                options = list(
    columnDefs = list(list(visible = FALSE, targets = c(1,2)))),
    callback=DT::JS("
  table.on('click.dt', 'tr', function() {
  
  // div ids of scatter and violinplot
  var id_scatter = 'scatter_{{ env_id }}';
  var id_violin = 'violin_{{ env_id }}';
  
  // get expression, featurenames and group_by values from table
  var exprs_str = table.row(this).data()[1];
  var group_str = table.row(this).data()[2];
  var featurename = table.row(this).data()[3];
  var expr = exprs_str.split(';').map(function(item){return parseFloat(item);});
  var group = group_str.split(';');
  
  // get min and max values from expression
  var min = Math.min(...expr);
  var max = Math.max(...expr);
  
  // get div container of plots
  var scatter_div = document.getElementById(id_scatter);
  var violin_div = document.getElementById(id_violin);
  
  // update scatter and violin layout - change title
  var scatter_layout_update = {title: featurename}
  var violin_layout_update = {'title': featurename,
  'xaxis.type': 'category'};
  
  // update scatterplot data
  var scatter_update_0 = {
  'marker.color': [expr],
  'marker.cmax': max,
  'marker.cmin': min,
  'marker.line.cmin': min,
  'marker.line.cmax': max,
  'marker.line.color': [expr]};

  var scatter_update_1 = {
  'marker.color': [min, max],
  'marker.cmax': max,
  'marker.cmin': min};
  
  // restyle and relayout of the scatterplot
  Plotly.restyle(id_scatter, scatter_update_0, [0]);
  Plotly.restyle(id_scatter, scatter_update_1, [1]);
  Plotly.relayout(id_scatter, scatter_layout_update);
  
  // create dict; key = number of level of group_by; value = indexes extractet from the hole expression array according to the level 
  level_indices = {}
  for (i = 0; i < violin_div.data.length; i++){
    level_name = violin_div.data[i].name;
    level_indices[i] = getAllIndexes(group, level_name);
  }
  traces_exprs = []
  // restyle each trace of the violinplot according to the indexes
  for (var key in level_indices){
    var exprs_of_level = level_indices[key].map(key => expr[key]);
    traces_exprs.push(exprs_of_level);
  }
  var violin_update = {
    y: traces_exprs
  }
  // all_traces = [...range(0, violin_div.data.length - 1)];
  Plotly.restyle(id_violin, violin_update);
  
  // change title of violinplot
  Plotly.relayout(id_violin, violin_layout_update);
  
  // function to get indexes
  function getAllIndexes(arr, val) {
    var indexes = [], i;
    for(i = 0; i < arr.length; i++)
        if (arr[i] === val)
            indexes.push(i);
    return indexes;
  }
  
  // highlight selected row of the table
  if ( $(this).hasClass('selected') ) {
      $(this).removeClass('selected');
  }
  else {
      table.$('tr.selected').removeClass('selected');
      $(this).addClass('selected');
  }
  
});
")
)
```

```{r, eval=is_shiny}
ui_list <- list()

# selection field for grouping
ui_list <- rlist::list.append(ui_list,
                                selectInput("select_grouping_env_blHKgM", label = "Select column for grouping:",
                                            choices = unique(data_env_blHKgM$group_by), selected = group_filter_env_blHKgM))
#
# subsetting data according to the selected grouping column
#
df_table_env_blHKgM <- shiny::reactive({
  selected_group <- input$select_grouping_env_blHKgM

  data_env_blHKgM %>%
    dplyr::filter(group_by == !!selected_group) 
})

#
# Dropdown menu with shiny input-widgets
#
shinyWidgets::dropdownButton(div(style='height: 300px; overflow-x: auto;',do.call(shiny::inputPanel, ui_list)),
                 circle = TRUE, status = "danger", icon = icon("gear"), width = "300px",
                 tooltip = shinyWidgets::tooltipOptions(title = "Click, to change plot settings:"))
#
# DT::datatable with calculated statistic
#
output$tbl_env_blHKgM <- DT::renderDataTable({
  options(DT.options = list(scrollY="400px",scrollX="300px", pageLength = 10, autoWidth = TRUE))
  df_table_env_blHKgM() %>%
    dplyr::group_by(level, feature) %>%
    dplyr::mutate(is_non_zero_exprs = expression > 0) %>%
    dplyr::summarise(n_samples = n(), n_nonzero = sum(is_non_zero_exprs)) %>%
    dplyr::mutate(freq = round(n_nonzero / n_samples * 100, 2)) %>%
    dplyr::mutate(info = paste0(n_nonzero, " / ", n_samples, " (", freq, "%)")) %>%
    dplyr::select(level, feature, info) %>%
    tidyr::spread(level, info) %>%
    dplyr::mutate(feature = row.names(exprs_values_env_blHKgM)) %>%
    DT::datatable(filter = 'top', selection = list(mode = 'single', selected = 1, target = 'row'))
})
DT::dataTableOutput('tbl_env_blHKgM')
```

Column
-------------------------------------

###

<!-- Component created on {{ date }} -->

```{r, eval=!is_shiny}
i2dash.scrnaseq::plotly_violinplot(y = exprs_values_{{ env_id }}[1,], group_by = group_by_{{ env_id }}[,1], y_title = "Expression per cluster", group_by_title = "Grouping") %>%
  plotly::layout(
    title = row.names(exprs_values_{{ env_id }})[1]
  ) -> violin_{{ env_id }}
violin_{{ env_id }}$elementId <- "violin_{{ env_id }}"
violin_{{ env_id }}
```
  
```{r, eval=is_shiny}
#
# subsetting the data.frame for the violinplot according to the transmitted keys from scatterplot
#
df2_env_blHKgM <- shiny::reactive({
  keys <- plotly::event_data("plotly_selected", source = "scatter_env_blHKgM")$key
  df <- data.frame(df_env_blHKgM()$df, "level" = as.factor(group_by_env_blHKgM[[input$select_grouping_env_blHKgM]]))
  if(!is.null(keys)) {
    return(df[keys, ])
  }
  return(df)
})

#
# creating a violinplot with the primitive function of i2dash.scrnaseq::plotly_violinplot
#
output$violin_env_blHKgM <- plotly::renderPlotly({
  i2dash.scrnaseq::plotly_violinplot(y = df2_env_blHKgM()$expression, group_by = df2_env_blHKgM()$level, y_title = "Expression per cluster", group_by_title = "Grouping") %>%
  plotly::layout(
    title = input$select_feature_env_blHKgM
  ) -> violin
})
plotly::plotlyOutput("violin_env_blHKgM", height = "100%")
```

### Select points to recalculate the violin plot according to selection:

```{r, eval=!is_shiny}
reduced_dim_{{ env_id }} %>%
  plotly::plot_ly(x = ~x , y= ~y, hoverinfo = "x+y+text", text = row.names(reduced_dim_{{ env_id }}), colors = "YlOrRd", color = exprs_values_{{ env_id }}[1,], type = "scattergl") %>%
  plotly::layout(
    title = row.names(exprs_values_{{ env_id }})[1],
    xaxis = list(title = "Dimension 1"),
    yaxis = list(title = "Dimension 2")
  ) %>% htmlwidgets::onRender("function(el) {
                                var id_violin = 'violin_{{ env_id }}';
                                var violin_div = document.getElementById(id_violin);

                                var div_group_by = document.getElementById('div_group_by_{{ env_id }}');
                                var group_str = div_group_by.getAttribute('data-grouping');
                                var group = group_str.split(';');

                                level_indices = {}
                                for (i = 0; i < violin_div.data.length; i++){
                                  level_name = violin_div.data[i].name;
                                  level_indices[i] = getAllIndexes(group, level_name);
                                }

                                el.on('plotly_selected', function(eventData){
                                  if(eventData == undefined){
                                    console.log('Nothing is selected');
                                  } else {
                                    feature_name = el.layout.title.text;
                                    var div_exprs = document.getElementById(feature_name);
                                    var exprs_str = div_exprs.getAttribute('data-expression');
                                    var expr = exprs_str.split(';').map(function(item){return parseFloat(item);});

                                    // get the array of the selected points
                                    var selection = eventData.points[0].data.selectedpoints;

                                    // create dict with subsetted trace indexes
                                    updated_dict = {}
                                    for (var key in level_indices){
                                      updated_dict[key] = selection.filter(value => -1 !== level_indices[key].indexOf(value))
                                    }

                                    // restyle each trace of the violinplot according to the indexes
                                    traces_exprs = []
                                    for (var key in updated_dict){
                                      if (updated_dict[key].length === 0){
                                        var exprs_of_level = [0];
                                        traces_exprs.push(exprs_of_level);
                                      } else {
                                        var exprs_of_level = updated_dict[key].map(key => expr[key]);
                                        traces_exprs.push(exprs_of_level);
                                      }
                                    }
                                    var violin_update = {
                                      y: traces_exprs
                                    }

                                    Plotly.restyle(id_violin, violin_update);
                                    console.log(updated_dict)

                                    var violin_layout_update = {'xaxis.type': 'category'};
                                    Plotly.relayout(id_violin, violin_layout_update);

                                    // when deselected the violin plot is restyled with the old values
                                    el.on('plotly_deselect', function(eventData){
                                      feature_name = el.layout.title.text;
                                      var div_exprs = document.getElementById(feature_name);
                                      var exprs_str = div_exprs.getAttribute('data-expression');
                                      var expr = exprs_str.split(';').map(function(item){return parseFloat(item);});

                                      traces_exprs = [];
                                      // restyle each trace of the violinplot according to the indexes
                                      for (var key in level_indices){
                                        var exprs_of_level = level_indices[key].map(key => expr[key]);
                                        traces_exprs.push(exprs_of_level);
                                      };
                                      var violin_update = {
                                        y: traces_exprs
                                      };
                                      // all_traces = [...range(0, violin_div.data.length - 1)];
                                      Plotly.restyle(id_violin, violin_update);

                                      var violin_layout_update = {'xaxis.type': 'category'};
                                      Plotly.relayout(id_violin, violin_layout_update);
                                    })
                                  }
                                });

                                // function to get indexes
                                function getAllIndexes(arr, val) {
                                  var indexes = [], i;
                                  for(i = 0; i < arr.length; i++)
                                    if (arr[i] === val)
                                      indexes.push(i);
                                  return indexes;
                                }

                              }") -> scatter_{{ env_id }}
scatter_{{ env_id }}$elementId <- "scatter_{{ env_id }}"
scatter_{{ env_id }}
```

```{r, eval=is_shiny}
#
# Create reactive data table for the scatterplot according to the selected feature
#
df_env_blHKgM <- shiny::reactive({
  selected_gene <- input$tbl_env_blHKgM_row_last_clicked
  if(is.null(selected_gene)){
    expression <- exprs_values_env_blHKgM[1,] 
    featurename <- featurenames[1]
  } else {
    expression <- exprs_values_env_blHKgM[selected_gene,]
    featurename <- featurenames[selected_gene]
  }
  df <- data.frame("x" = reduced_dim_env_blHKgM[,1], "y" = reduced_dim_env_blHKgM[,2], "expression" = expression)
  return(list("df" = df, "feature" = featurename))
})

#
# Output
#
output$scatter_env_blHKgM <- plotly::renderPlotly({
  df_env_blHKgM()$df %>%
    plotly::plot_ly(x = ~x, y = ~y, hoverinfo = "x+y+text", text = rownames(df_env_blHKgM()$df), colors = "YlOrRd", color = ~expression, source = "scatter_env_blHKgM", key = rownames(df_env_blHKgM()$df)) %>%
    plotly::layout(
      xaxis = list(title = "Dimension 1"),
      yaxis = list(title = "Dimension 2"),
      title = df_env_blHKgM()$feature) %>% 
    plotly::event_register("plotly_selected") -> plot
  plot
})
plotly::plotlyOutput("scatter_env_blHKgM", height = "100%")
```
