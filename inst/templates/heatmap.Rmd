
### {{ title }}

<!-- Component created on {{ date }} -->

```{r}
{{ env_id }} <- readRDS(file.path(datadir, "{{ env_id }}.rds"))
is_shiny <- identical(knitr::opts_knit$get("rmarkdown.runtime"), "shiny")
library(magrittr)

```

```{r}
#
# Method for creating a data.table required by create_heatmap() method from wilson.
#
create_data.table <- function(matrix, group_by){
  # validate input
  if(ncol(matrix) != length(group_by)) stop("The length of the vector 'group_by' should be of the same length as the column number of 'matrix'.")
  # create data.table
  dt <- data.table::data.table(t(matrix))
  dt[, cell    := dimnames(matrix)[2]]
  dt[, grouping := group_by]
  # Melt
  dt <- data.table::melt(dt, id.vars = c('cell', 'grouping'), variable.name='gene')
  # Aggregate
  dt2 <- dt[, .(meanvalue = mean(value)), by = c('grouping', 'gene')]
  # Cast
  dt3 <- dt2 %>% data.table::dcast(gene ~ grouping, value.var = 'meanvalue')
  # change categorical 'gene' column to character
  dt3[[1]] <- as.character(dt3[[1]])
  dt3 %<>% 
    tibble::column_to_rownames("gene") %>%
    data.matrix(rownames.force = T)
  return(dt3)
}
```


```{r, eval=!is_shiny}
if(!is.null({{ env_id }}$column_split)){
  if({{ env_id }}$visualisation_mode == "splitted"){
    exprs_values_{{ env_id }} <- {{ env_id }}$exprs_values
    colnames(exprs_values_{{ env_id }}) <- c()
    column_split_{{ env_id }} <- {{ env_id }}$column_split[,1]
    column_names_rot_{{ env_id }} <- NULL
    cell_fun_{{ env_id }} <- NULL
  } else if({{ env_id }}$visualisation_mode == "summarized"){
    exprs_values_{{ env_id }} <- create_data.table({{ env_id }}$exprs_values, {{ env_id }}$column_split[,1])
    column_split_{{ env_id }} <- NULL
    column_names_rot_{{ env_id }} <- 45
    cell_fun_{{ env_id }} <- function(j, i, x, y, width, height, fill) {
      grid::grid.text(sprintf("%.1f", exprs_values_{{ env_id }}[i, j]), x, y, gp = grid::gpar(fontsize = 10))
    }
  }
} else {
  exprs_values_{{ env_id }} <- {{ env_id }}$exprs_values
  colnames(exprs_values_{{ env_id }}) <- c()
  column_split_{{ env_id }} <- {{ env_id }}$column_split
  column_names_rot_{{ env_id }} <- NULL
  cell_fun_{{ env_id }} <- NULL
}

row_split_{{ env_id }} <- {{ env_id }}$row_split[,1]

# Provide data for download
# htmltools::tags$button(i2dash::embed_var(exprs_values_{{ env_id }})) # prevents large size of the plot
# htmltools::tags$br()

# Render plot
i2dash.scrnaseq::ComplexHeatmap_heatmap(
    matrix = exprs_values_{{ env_id }},
    legend_title = {{ env_id }}$legend_title,
    cluster_rows = {{ env_id }}$cluster_rows,
    cluster_columns = {{ env_id }}$cluster_columns,
    clustering_distance_rows = {{ env_id }}$clustering_distance,
    clustering_distance_columns = {{ env_id }}$clustering_distance,
    clustering_method_rows = {{ env_id }}$clustering_method,
    clustering_method_columns = {{ env_id }}$clustering_method,
    column_split = column_split_{{ env_id }},
    row_split = row_split_{{ env_id }},
    column_names_rot = column_names_rot_{{ env_id }},
    cell_fun = cell_fun_{{ env_id }}
  )
```

```{r, eval=is_shiny}
ui_list <- list()
# selection of the visualisation mode:
if (!is.null({{ env_id }}$column_split)){
  ui_list <- rlist::list.append(ui_list,
                                radioButtons("select_visualisation_{{ env_id }}", label = "Columns by:",
                                            choices = c("samples", colnames({{ env_id }}$column_split))))
}
# selection field for splitting the columns
if (!is.null({{ env_id }}$column_split)){
  ui_list <- rlist::list.append(ui_list,
                                selectInput("select_column_split_{{ env_id }}", label = "(If 'samples' selected) Column splitting:",
                                            choices = c("none", colnames({{ env_id }}$column_split))))
}

# subset the genes
ui_list <- rlist::list.append(ui_list,
                                selectInput("select_subset_{{ env_id }}",
                                  label = "Select features:",
                                  choices = rownames({{ env_id }}$exprs_values),
                                  multiple = TRUE)
                              )

# select clustering
ui_list <- rlist::list.append(ui_list,
                                radioButtons("select_clustering_{{ env_id }}",
                                  label = "Select clustering:",
                                  choices = c("no clustering" = "none", "columns and rows" = "both", "only columns" = "column", "only rows" = "row"))
                              )
# select clustering distance
ui_list <- rlist::list.append(ui_list,
                                selectInput("select_clustdist_{{ env_id }}",
                                  label = "Cluster distance:",
                                  choices = c("euclidean", "maximum", "manhattan", "binary", "minkowski"),
                                  multiple = FALSE)
                              )
# select clustering method
ui_list <- rlist::list.append(ui_list,
                                selectInput("select_clustmethod_{{ env_id }}",
                                  label = "Cluster method:",
                                  choices = c("average", "ward.D", "ward.D2", "single", "complete", "mcquitty"),
                                  multiple = FALSE)
                              )

# Download link
ui_list <- rlist::list.append(ui_list, tags$div(tags$br(), downloadButton('downloadData_{{ env_id }}', 'Download data')))

# Function for subsetting a matrix accoriding to a vector of features
subset_features <- function(matrix, features){
  if(length(features) > 1){
    matrix <- matrix[features,]
  } else if(length(features) == 1){
    matrix <- matrix[features,,drop = FALSE]
  }
  return(matrix)
}

#
# Handle inputs
#
exprs_values_{{ env_id }} <- shiny::reactive({
  exprs_values <- {{ env_id }}$exprs_values
  if(!is.null({{ env_id }}$column_split)){
    if(input$select_visualisation_{{ env_id }} == "samples"){
      colnames(exprs_values) <- c()
      exprs_values <- subset_features(exprs_values, input$select_subset_{{ env_id }})
      return(exprs_values)
    } else {
      create_data.table(exprs_values, {{ env_id }}$column_split[[input$select_visualisation_{{ env_id }}]]) %>%
      subset_features(features = input$select_subset_{{ env_id }}) -> exprs_values
      return(exprs_values)
    }
  } else {
    colnames(exprs_values) <- c()
    exprs_values <- subset_features(exprs_values, input$select_subset_{{ env_id }})
    return(exprs_values)
  }
})

clust_{{ env_id }} <- shiny::reactive({
  clustering <- input$select_clustering_{{ env_id }}
  if (clustering == "none") {
    cluster_rows <- FALSE
    cluster_columns <- FALSE
  } else if (clustering == "row") {
    cluster_rows <- TRUE
    cluster_columns <- FALSE
  } else if (clustering == "column") {
    cluster_rows <- FALSE
    cluster_columns <- TRUE
  } else if (clustering == "both") {
    cluster_rows <- TRUE
    cluster_columns <- TRUE
  }
  return(list(rows = cluster_rows, columns = cluster_columns))
})

column_split_{{ env_id }} <- shiny::reactive({
  if(!is.null({{ env_id }}$column_split)){
    if(input$select_visualisation_{{ env_id }} == "samples"){
      if(input$select_column_split_{{ env_id }} != "none"){
        return({{ env_id }}$column_split[[input$select_column_split_{{ env_id }}]])
      }
    }
  }
})

#
# Generate plot
#
output$plot_{{ env_id }} <- renderPlot({
  clustdist <- input$select_clustdist_{{ env_id }}
  clustmethod <- input$select_clustmethod_{{ env_id }}
  
  if(!is.null({{ env_id }}$column_split)){
    if(input$select_visualisation_{{ env_id }} == "samples"){
      cell_fun <- NULL
      column_names_rot = NULL
    } else {
      cell_fun <- function(j, i, x, y, width, height, fill) {
        grid::grid.text(sprintf("%.1f", exprs_values_{{ env_id }}()[i, j]), x, y, gp = grid::gpar(fontsize = 10))
      }
      column_names_rot = 45
    }
  } else {
    cell_fun <- NULL
    column_names_rot = NULL
  }
  
  i2dash.scrnaseq::ComplexHeatmap_heatmap(
    matrix = exprs_values_{{ env_id }}(),
    legend_title = {{ env_id }}$legend_title,
    cluster_rows = clust_{{ env_id }}()$rows,
    cluster_columns = clust_{{ env_id }}()$columns,
    clustering_distance_rows = clustdist,
    clustering_distance_columns = clustdist,
    clustering_method_rows = clustmethod,
    clustering_method_columns = clustmethod,
    column_split = column_split_{{ env_id }}(),
    column_names_rot = column_names_rot,
    cell_fun = cell_fun
  )
})

#
# Download
#
output$downloadData_{{ env_id }} <- downloadHandler(
  filename =  paste('data-', Sys.Date(), '.csv', sep=''),
  content = function(file) {
    write.csv(exprs_values_{{ env_id }}(), file)
  }
)

#
# Layout of component
#
shiny::fillRow(flex = c(NA, 1),
      shinyWidgets::dropdownButton(div(style='max-height: 350px; overflow-x: auto;',do.call(shiny::inputPanel, ui_list)),
                       circle = TRUE, status = "danger", icon = icon("gear"), width = "300px",
                       tooltip = shinyWidgets::tooltipOptions(title = "Click, to change plot settings:")),
      plotOutput("plot_{{ env_id }}", width = "100%", height = "400px")
)
```

