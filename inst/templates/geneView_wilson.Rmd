
### {{ title }}

<!-- Component created on {{ date }} -->

```{r}
{{ env_id }} = readRDS("envs/{{ env_id }}.rds")

is_shiny <- identical(knitr::opts_knit$get("rmarkdown.runtime"), "shiny")
```

```{r, eval=!is_shiny}
# Parameters for wilson::create_scatterplot
"%ni%" <- Negate("%in%")
additional_arguments <- {{ env_id }}$additional_arguments

# todo provide color for categorial and sequential data
# if("data.method" %ni% names(additional_arguments)){
#   additional_arguments$plot.method <- "static"
# }
# if("density" %ni% names(additional_arguments)){
#   additional_arguments$density <- F
# }
# if("line" %ni% names(additional_arguments)){
#   additional_arguments$line <- F
# }
# if("categorized" %ni% names(additional_arguments)){
#   additional_arguments$categorized <- F
# }
# # Set values for 'x'
# x <- {{ env_id }}$x[1]
# 
# # Set values for 'y'
# y <- {{ env_id }}$y[1]
# 
# # Set values for 'colour_by'
# if (!is.null({{ env_id }}$colour_by)){
#   colour_by <- {{ env_id }}$colour_by[1]
# }
# 
# # Set values for id'
# id <- c(1:length(x[[1]]))
#   
# # Create a data.frame
# df <- data.frame(id, x, y)
#   
# # if colour_by provided
# if(!is.null({{ env_id }}$colour_by)){
#   df["colour_by"] <- colour_by
#   # if colour_by is character
#   if(is.character(df[["colour_by"]])){
#     additional_arguments$categorized <- T
#   # if colour_by is factor
#   } else if (is.factor(df[["colour_by"]])){
#     additional_arguments$categorized <- T
#     df["colour_by"] <- droplevels(df["colour_by"])
#   # if colour_by is numeric
#   } else if (is.numeric(df[["colour_by"]])){
#     if("categorized" %in% names({{ env_id }}$additional_arguments)){
#       additional_arguments$categorized <- {{ env_id }}$additional_arguments$categorized
#     }
#   }
# }
# 
# # color
# if(additional_arguments$categorized){
#   # categorical (qualitative) color palettes
#   if("color" %ni% names({{ env_id }}$additional_arguments)){
#     color <- RColorBrewer::brewer.pal(8, "Accent")
#     additional_arguments$color <- color
#   }
# } else {
#   # sequential (one-sided) color palettes
#   if("color" %ni% names({{ env_id }}$additional_arguments)){
#     color <- RColorBrewer::brewer.pal(9, "YlOrRd")
#     additional_arguments$color <- color
#   }
# }
# 
# # Create data.table from data.frame
# dt <- data.table::setDT(df)
# additional_arguments$data <- dt
# 
# # Provide data for download
# i2dash::embed_var(dt)
# 
# # Render plot
# output_list <- do.call(wilson::create_scatterplot, additional_arguments)
# gg <- output_list$plot
#     
# # convert to plotly object for automatic resizing
# plotly::ggplotly(gg)
```

```{r, eval=is_shiny}
ui_list <- list()

# select type of plot
ui_list <- rlist::list.append(ui_list,
                                selectInput("select_type_{{ env_id }}", label = "Type of Plot:",
                                            choices = c("box", "line", "violin", "bar"), selected = "line"))

# selection field for data
if ({{ env_id }}$x_selection){
  ui_list <- rlist::list.append(ui_list,
                                selectInput("select_data_{{ env_id }}", label = "Select data:",
                                            choices = names({{ env_id }}$data)))
}

# selection field for condition
if ({{ env_id }}$group_by_selection){
  ui_list <- rlist::list.append(ui_list,
                                selectInput("select_group_by_{{ env_id }}", label = "Select condition:",
                                            choices = names({{ env_id }}$group_by)))
}

# selection field for colour_by
# if ({{ env_id }}$colour_by_selection){
#   ui_list <- rlist::list.append(ui_list,
#                                 selectInput("select_colour_{{ env_id }}", label = "Select individual column(s):",
#                                             choices = names({{ env_id }}$colour_by)))
# }

# Download link
ui_list <- rlist::list.append(ui_list, tags$div(tags$br(), downloadButton('downloadData_{{ env_id }}', 'Download data')))

#
# Create reactive data table
#
df_{{ env_id }} <- shiny::reactive({
  
  # Parameters for wilson::create_scatterplot
  # params <- list()
  "%ni%" <- Negate("%in%")
  additional_arguments <- {{ env_id }}$additional_arguments
  
  # todo provide color for categorial and sequential data
  if("plot.method" %ni% names(additional_arguments)){
    additional_arguments$plot.method <- "static"
  }
  # not forget in static mode: additional_arguments$plot.type <- "line"
  if("plot.type" %ni% names(additional_arguments)){
    additional_arguments$plot.type <- input$select_type_{{ env_id }}
  }
  
  ###########
  # To Do: create data.frames "data" and "grouping" from provided data

  # Create data.table from data.frames
  
  # data <- data.table::setDT(df)
  # additional_arguments$data <- data
  # 
  # grouping <- data.table::setDT(gr_df)
  # additional_arguments$grouping <- grouping
  # 
  # return(list("params" = additional_arguments, "data" = data, "grouping" = grouping))
})

#
# Download
#
############
# To do: provide both data.frames for download
output$downloadData_{{ env_id }} <- downloadHandler(
  filename =  paste('data-', Sys.Date(), '.csv', sep=''),
  content = function(file) {
    write.csv(df_{{ env_id }}()$data, file)
  }
)

#
# Output
#
output$plot_{{ env_id }} <- plotly::renderPlotly({
    output_list <- do.call(wilson::create_geneview, df_{{ env_id }}()$params)
    gg <- output_list$plot
    
    # convert to plotly object for automatic resizing
    plotly::ggplotly(gg)
})

#
# Layout of component
#
shiny::fillCol(flex = c(NA, 1),
        do.call(shiny::inputPanel, ui_list),
        plotly::plotlyOutput("plot_{{ env_id }}", height = "100%")
)
```
