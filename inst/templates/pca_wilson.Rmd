
### {{ title }}

<!-- Component created on {{ date }} -->

```{r}
{{ env_id }} = readRDS("envs/{{ env_id }}.rds")

is_shiny <- identical(knitr::opts_knit$get("rmarkdown.runtime"), "shiny")
```

```{r, eval=!is_shiny}
# # Parameters for wilson::create_scatterplot
# "%ni%" <- Negate("%in%")
# additional_arguments <- {{ env_id }}$additional_arguments
# 
# if("clustering" %ni% names({{ env_id }}$additional_arguments)){
#   additional_arguments$clustering <- "none"
# }
# if("clustdist" %ni% names({{ env_id }}$additional_arguments)){
#   additional_arguments$clustdist <- "euclidean"
# }
# if("clustmethod" %ni% names({{ env_id }}$additional_arguments)){
#   additional_arguments$clustmethod <- "average"
# }
# additional_arguments$plot.method <- "interactive"
# 
# if("color" %ni% names({{ env_id }}$additional_arguments)){
#     color <- RColorBrewer::brewer.pal(9, "YlOrRd")
#     additional_arguments$color <- color
# }
# # set variables
# countTable <- {{ env_id }}$countTable
# group_by <- {{ env_id }}$group_by[1]
# 
#  # create data.table
# dt <- create_data.table('matrix' = countTable, 'group_by' = group_by[[1]])
# additional_arguments$data <- dt
# 
# # Provide data for download
# i2dash::embed_var(dt)
# 
# # Render plot
# output_list <- do.call(wilson::create_heatmap, additional_arguments)
# heatmap <- output_list$plot
# # reset the width and hight of the plotly object for automatic scaling
# heatmap$x$layout$height <- 0
# heatmap$x$layout$width <- 0
# heatmap
```

```{r, eval=is_shiny}
########
library(shinyWidgets)
######

ui_list <- list()

# selection field for group_by
if ({{ env_id }}$colour_by_selection){
  ui_list <- rlist::list.append(ui_list,
                                selectInput("select_colour_by_{{ env_id }}", label = "Select colouring:",
                                            choices = names({{ env_id }}$group_by)))
}

# subset
ui_list <- rlist::list.append(ui_list,
                                selectInput("select_subset_{{ env_id }}",
                                  label = "Select columns:",
                                  choices = colnames({{ env_id }}$countTable),
                                  multiple = TRUE)
                              )

# select PCA dim. on x-axis
ui_list <- rlist::list.append(ui_list,
                                numericInput("dim_a_{{ env_id }}", label = "PCA dimension (x-axis)", min = 1, max = 6, step = 1, value = 1))
# select PCA dim. on y-axis
ui_list <- rlist::list.append(ui_list,
                                numericInput("dim_b_{{ env_id }}", label = "PCA dimension (y-axis)", min = 1, max = 6, step = 1, value = 2))

# Download link
ui_list <- rlist::list.append(ui_list, tags$div(tags$br(), downloadButton('downloadData_{{ env_id }}', 'Download data')))

#
# Create reactive data table
#
df_{{ env_id }} <- shiny::reactive({
  
  # Parameters for wilson::create_scatterplot
  # params <- list()
  "%ni%" <- Negate("%in%")
  additional_arguments <- {{ env_id }}$additional_arguments
  
  # "static" not possible yet
  additional_arguments$plot.method <- "interactive"
  
  # Set values for 'countTable'
  countTable <- {{ env_id }}$countTable
  
  # categorical (qualitative) color palette
  if("color" %ni% names({{ env_id }}$additional_arguments)){
    color <- RColorBrewer::brewer.pal(8, "Accent")
    additional_arguments$color <- color
  }
  if("labels" %ni% names({{ env_id }}$additional_arguments)){
    additional_arguments$labels <- TRUE
  }
  if("dimensions" %ni% names({{ env_id }}$additional_arguments)){
    additional_arguments$dimensions <- 6
  }
  additional_arguments$dimension.a <- input$select_clustering_{{ env_id }}
  additional_arguments$dimension.b <- input$select_clustdist_{{ env_id }}
  
  # Set values for 'colour_by'
  if( !{{ env_id }}$colour_by_selection ) {
    colour_by <- {{ env_id }}$colour_by[1]
  } else {
    colour_by <- {{ env_id }}$colour_by[input$select_colour_by_{{ env_id }}]
  }
  
  # subset countTable by chosen columns
  if(!is.null(input$select_subset_{{ env_id }})){
    subset_samples <- input$select_subset_{{ env_id }}
    if(length(subset_samples) >= 3){
      countTable <- countTable[,subset_samples]
    }
  }
  
  # create data.table
  data <- data.table::data.table("features" = as.character(rownames(countTable)), countTable)
  additional_arguments$data <- data
  additional_arguments$color.group <- colour_by
  
  return(list("params" = additional_arguments, "data" = data))
})

#
# Download
#
output$downloadData_{{ env_id }} <- downloadHandler(
  filename =  paste('data-', Sys.Date(), '.csv', sep=''),
  content = function(file) {
    write.csv(df_{{ env_id }}()$data, file)
  }
)

#
# Output
#
output$plot_{{ env_id }} <- plotly::renderPlot({
  output_list <- do.call(wilson::create_pca, df_{{ env_id }}()$params)
  plot <- output_list$plot
  # reset the width and hight of the plotly object for automatic scaling
  #heatmap$x$layout$height <- 0
  #heatmap$x$layout$width <- 0
  plot
})

#
# Layout of component
#
shiny::fillRow(flex = c(NA, 1),
        dropdownButton(do.call(shiny::inputPanel, ui_list),
                       circle = TRUE, status = "danger", icon = icon("gear"), width = "300px",
                       tooltip = tooltipOptions(title = "Click, to change plot settings:")),
        plotOutput("plot_{{ env_id }}")
)
```
